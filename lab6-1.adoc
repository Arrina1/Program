:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
:stem:
:sectnums:

= Лабораторная работа №6

Таймеры и системы тактирования. Порты

[.text-right]
Автор работы: Студент группы КЭ-413 +
А.М. Жуламанова

<<<
== Цель лабораторной работы

Произвести настройку Tim2 (сделать его насройку, запустить, проверить флаг переполнения).

Оформить лабораторную с описанием системы тактирования, настройки на внешний и внутренний источник тактирования, PLL, привести подробно настройку работы портов, привести примеры кода, картинки.

== Описание системы тактирования

Система тактирования — это подсистема микроконтроллера, которая обеспечивает стабильную и точную работу процессора, периферии и других внутренних блоков. Основные задачи системы тактирования:

* Генерация базового тактового сигнала
* Формирование частоты тактирования с помощью умножителей/делителей (PLL)
* Возможность выбора источника тактирования (внутренний или внешний генератор)

Типичные источники тактирования:

* Внутренний RC-генератор (внутренний осциллятор) HSI (high-speed internal) 
* HSE (high-speed external)
* PLL (фазовращающий контур) для умножения частоты

.Система тактирования микроконтроллера STM32F411
image::derevo.png[]

== Настройка на внешний и внутренний источник тактирования

=== Внутренний источник тактирования

* Как правило, внутренний RC-генератор небольшой точности, но быстрого запуска.
* Для переключения на внутренний генератор обычно используется бит выбора источника в регистре тактирования (например, CLK_SRC = 0).
* Частота внутреннего генератора фиксирована.

=== Внешний источник тактирования

* Используется внешний генератор с высокой стабильностью.
* Для активации внешнего источника устанавливается бит выбора (CLK_SRC = 1), а также запускается и ждёт стабилизации внешний осциллятор.

== PLL (фазовращающий контур)

* PLL позволяет увеличить частоту тактового сигнала до нужного значения.

* Работает путём умножения и деления частоты выбранного источника (внутреннего или внешнего).

=== Настройка PLL включает:

. Выбор входного источника (внутренний или внешний)
. Установка коэффициентов умножения и деления
. Включение PLL и ожидание стабилизации
. Переключение на PLL как источник системного тактирования

== Настройка первичных источников тактирования

Настройка основных источников тактирования выполняется через три главных регистра:

* RCC_CR
* RCC_CFGR
* RCC_PLLCFGR

*RCC* - управление сбросоми и тактовой частотой / системой тактирования.

Модуль RCC отвечат за:

* управление тактовой частотой (Clock Control):
** генерация тактовых сигналов для всех компонентов микроконтроллера: ядра, памяти, периферии (USART, SPI, TIM);
** Выбор источника тактирования: внешний кварцевый резонатор (HSE), внутренний RC-генератор (HSI), внутренний низкочастотный генератор (LSI) для сторожевых таймеров, внешний низкочастотный резонатор (LSE) для часов реального времени;
** Настройка частоты с помощью PLL (ФАПЧ - петля фазовой автоподстройки частоты) для повышения частоты до нужного значения;
** Распределение тактовых сигналов по шинам (AHB, APB1, APB2);
** Включение/выключение тактирования отдельных периферийных модулей (для экономии энергии);
* управление сбросом (Reset Control):
** Обработка различных источников сигнала сброса:
*** Сигнал сброса по питанию (POR/PDR).
*** Внешний вывод сброса (NRST).
*** Сброс от сторожевого таймера (IWDG, WWDG).
*** Программный сброс.
*** Сброс при переходе в режим ожидания.
** Определение причины последнего сброса (чечтение флагов в регистрах RCC), что помогает при отладке.

Включение и выключение источников происходит через регистр CR (Clock Control register). 

.Регистр CR.
image::cr.png[]

.Контроль работы
|===
||PLL|HSE|HSI
|RDY|Bit [25]|Bit [17]|Bit [1]
|ON|Bit [24]|Bit [16]|Bit [0]
|===

Здесь есть специальные биты, отвечающие за запуск генераторов (например, HSE, HSI, PLL): чтобы активировать источник, выставляют бит ON в 1, чтобы отключить — в 0. После команды включения необходима пауза — система аппаратно устанавливает бит RDY (ready), который сигнализирует о готовности источника. Пока RDY равен 0, источник ещё не стабилен и не готов к использованию.

После того как нужный источник тактовой частоты активен, происходит переключение системной частоты (SYSCLK) через регистр CFGR. 

.Регистр CFGR.
image::cfgr.png[]

Здесь используются 4 младших бита — две пары: SW (switch) и SWS (switch status).

* SW — программный выбор источника тактирования,
* SWS — аппаратное подтверждение текущего активного источника.

Возможные значения для SW и SWS:

* 00 — выбран внутренний генератор HSI,
* 01 — выбран внешний генератор HSE,
* 10 — выбран источник PLL.

Для надёжной работы нужно убедиться, что аппаратный статус SWS совпадает с программным выбором SW, то есть переключение успешно завершено.

Настройка параметров PLL производится с помощью отдельного регистра PLLСFGR. 

.Регистр PLLСFGR
image::pllcfgr.png[]

Этот регистр следует сконфигурировать до включения PLL. В нём устанавливаются значения множителей и делителей, которые формируют конечную частоту тактирования. Частоту можно вычислить по формуле:

====
f = f(вход PLL) × (PLLN / PLLM) / PLLP
====

Таким образом, изменение значений PLLN, PLLM и PLLP позволяет получить практически любую частоту работы до 100 МГц (в зависимости от возможностей конкретного контроллера).

В итоге настройка тактирования выглядит так:

. Включить нужный источник в регистре RCC_CR и дождаться готовности (появления бита RDY).
. Настроить делители и множители PLL в RCC_PLLCFGR до запуска PLL.
. Включить PLL и дождаться его готовности.
. Переключить системный тактовый сигнал на выбранный источник в RCC_CFGR.
. Проверить через биты SWS, что переключение завершено корректно.

== Пример настройки

*Настройка HSE*

[source, cpp]
----
  RCC::CR::HSEON::On::Set(); // <1>
  while (RCC::CR::HSERDY::NotReady::IsSet()) // <2> 
  {

  }
  RCC::CFGR::SW::Hse::Set(); //<3>
  while (!RCC::CFGR::SWS::Hse::IsSet())//<4>
  {

  }
  RCC::CR::HSION::Off::Set(); //<5> 
----

. включили
. проверили включение
. перекинули ключ SW на HSE
. проверили, что ключ переключился
. отключили HSI

*Настройка PLL на 36 МГц на основе HSE*

[source, cpp]
----
  RCC::PLLCFGR::PLLSRC::HseSource::Set(); //1
  
  RCC::PLLCFGR::PLLN0::Set(64); // n = 64
  RCC::PLLCFGR::PLLP0::Set(3); // p = 8
  RCC::PLLCFGR::FieldValues::Set(2); // m = 2
  //2
 RCC::CR::PLLON::On::Set(); //3
  while (RCC::CR::PLLRDY::Unclocked::IsSet()) //4
  {

  }
  RCC::CFGR::SW::Pll::Set(); //5
  while (!RCC::CFGR::SWS::Pll::IsSet()) //6
  {

  }
----

. настроили источник ФАПЧ на HSE
. определили коэффициенты 
. включили
. проверили, что включили
. перевели SW на PLL
. проверили, что перевели

Как подбирали коэффициенты (по логике):

. Выбор источника (HSE = 8 МГц)
** Взято физическое значение кварцевого резонатора на плате, обычно 8 МГц для отладочных плат;
. Выбор делителя M = 2.
*Ограничение*: Входная частота PLL (VCO_in) должна быть 1-2 МГц (для F4);
. Выбор множителя N = 64
* 256 МГц в диапазоне 192-432 МГц;
. Выбор постделителя P = 8
* P=3 (делитель 8) → 256 / 8 = 32 МГц 

.Ограниченичения на коэффициенты 1
image::zn1.jpg[] 
.Ограниченичения на коэффициенты 2
image::zn2.jpg[] 
.Ограниченичения на коэффициенты 3
image::zm3.jpg[]

== Таймеры. Настройка

Самый простой таймер для настройки имеет следующие характеристики:

* 24-битный таймер;

Для работы с таймером используются 3 основных регистра:

* LOAD — в этот регистр записывается значение, с которого таймер начнёт обратный отсчёт.
* VAL — здесь хранится текущее значение таймера, то есть сколько осталось до завершения отсчёта.
* CTRL — регистр управления, с помощью которого можно выбрать источник тактирования таймера, а также включить или выключить сам таймер.

Краткий алгоритм запуска и работы для задания нужного периода:
. Рассчитать LOAD = (частота_ядра × период_сек) - 1
. Остановить таймер (CTRL = 0)
. Записать LOAD в регистр LOAD
. Сбросить VAL (записать 0)
. Настроить CTRL: CLKSOURCE=1, TICKINT=1, ENABLE=1
. Использовать через прерывания или опрос флага

=== Таймер TIM2

32-битный универсальный таймер, аналогичный TIM5.

Он управляется с помощью 5 регистров:

* PSC — предделитель частоты, который позволяет уменьшить скорость счета таймера, делая переполнение более медленным.
* ARR — регистр автоперезагрузки, задает время, по достижении которого таймер сбрасывается и начинает отсчет заново.
* CNT — текущий счётчик, в котором хранится текущее значение таймера.
* SR::UIF — флаговое поле в регистре состояния, сигнализирующее о наступлении события (например, переполнение или обнуление) и вызывающее прерывание.
* CR1::CEN — бит в регистре управления, отвечающий за включение или отключение таймера.

Краткий алгоритм запуска и работы для задания нужного периода:
* Включить тактирование TIM2;
* Остановить таймер (CEN=0);
* Рассчитать PSC и ARR из формулы периода;
* Установить PSC, ARR, сбросить CNT;
* Очистить SR;
* Включить прерывание (если нужно);
* Запустить таймер (CEN=1);
* В обработчике всегда сбрасывать UIF.

=== Примеры настройки

==== Настройки системного таймера:

. Определяем задержку
. Устанавливаем задержку на 1 мс
. Сбрасываем текущее значение
. Устанавливаем HSI как источник тактирования (он и по умолчанию 0, но для наглядности)
. Включаем
. Проверяем флаг на переполнение

[source, cpp]
----
#include "stkregisters.h" // для системного таймера

std::uint32_t SystemCoreClock = 16000000U;
std::uint32_t ticks = SystemCoreClock/1000U-1U; // 1
extern "C" {
int __low_level_init(void)
{
  STK::LOAD::RELOAD::Set(ticks); // 2
  STK::VAL::Write(0); //3
  STK::CTRL::CLKSOURCE::Set(0); //4
  STK::CTRL::ENABLE::Enable::Set(); // 5
  
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////////
int main()
{ 
  /////////////////////////////////////
  for(;;)
  {   
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    if (STK::CTRL::COUNTFLAG::Overflow::IsSet()) // 6
    {
      modeController.RunCurrentMode(); 
    }
  }
  return 1;
}
----

.Работа
image::tim.gif[]

==== Настройка таймера TIM2

[source, cpp]
----
#include "tim2registers.hpp" // for tim2

const std::uint32_t SystemCoreClock = 16000000U; // частота тактирования при подключении к hsi
const std::uint16_t  timPresc = 1U; //PSC
const std::uint32_t timPeriod = SystemCoreClock/(timPresc*1000U)-1U; // задержка 1 мс

extern "C" {
int __low_level_init(void)
{
  RCC::APB1ENR::TIM2EN::Enable::Set(); // подаем тактирование

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////
void SetTimeout(std::uint32_t delayInms) // настройка таймера 2
{
  TIM2::PSC::Set(timPresc - 1U);// устанавливаем делитель частоты в 0
  TIM2::ARR::Write(delayInms * timPeriod); // T = 1*dealayInms ( // записываем значение для задержки в 1 мс)
  TIM2::SR::UIF::Set(0); // сбрасываем флаг генерации прерывания
  TIM2::CNT::Set(0);// сбрасываем счетчик в 0
  TIM2::CR1::CEN::Set(1);// запускаем таймер
}
int main()
{ 
 /////////////////////////////////
  SetTimeout(200U); // задержка
   for(;;)
  {  
    if (IsTimeoutExpired()) // если произошло прерывание
    {
       if (userButton.WasPressed()) 
       {
         modeController.SwitchMode(); 
       }
      modeController.RunCurrentMode();
    } 
  }
  return 1;
}
----

=== Настройки порта

==== Основные сведения:

В рассматриваемом микроконтроллере присутствуют 5 типов портов, каждый из которых имеет 16 линий ввода/вывода.

Поддерживаются такие режимы входа:

* Плавающий цифровой — не рекомендуется использовать, кроме случаев создания радиопомех или экспериментов.
* Цифровой с подтяжкой к 0 или 1 — линия по умолчанию подключена к одному из уровней (0 или 1). При событии (например, замыкании) уровень меняется на противоположный. Часто подтяжку выполняют аппаратно, так как она надежнее встроенной с непредсказуемыми параметрами.
* Аналоговый вход — воспринимает аналоговый сигнал и интерпретирует значения выше среднего напряжения как 1, а ниже — как 0. Рекомендуется подавать сигналы, максимально близкие к 0 или 1, чтобы избежать ошибок распознавания.

.Цифровой вход с подтяжкой.
image::pull_up_down.png[]

.Подача питания или отключение
image::port_off_on.png[]


Режим цифрового выхода позволяет программно переключать линию между уровнями 0 и 1.

Для режимов с большими токами доступны:

* Альтернативная функция с открытым коллектором с подтяжкой (pull-up или pull-down)
* Альтернативная функция двухтактный выход с подтяжкой

==== Про регистры

* GPIOx_ODR — регистр выходных данных, управляет состоянием линий в режиме выхода.
* GPIOx_IDR — регистр входных данных, позволяет считывать состояние линий в режиме входа.
* GPIOx_MODER — задаёт режим работы каждого пина: вход, выход, аналоговый, или альтернативная функция.
* GPIOx_PUPDR — контролирует внутренние резисторы подтяжки: плавающий, подтяжка к 0 или к 1.
* GPIOx_SPEEDR — задаёт скорость переключения линий. Не рекомендуется ставить максимальную скорость на все линии, чтобы снизить энергопотребление.
* GPIOx_BSRR — позволяет атомарно устанавливать или сбрасывать биты GPIOx_ODR:
* младшие 16 бит — установка линии в 1,
* старшие 16 бит — сброс линии в 0.

*Важно*: запись 0 не меняет состояние, управляющим является бит, установленный в 1.

Приведем настройки:

[source, cpp]
----
int main()
{ 
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
}  
----

== Заключение

В ходе работы изучена основная периферия микроконтроллеров — порты, таймеры и источники тактирования. Рассмотрены ключевые особенности настройки источников тактирования, системного таймера и 32-битных таймеров общего назначения.

Особое внимание уделено влиянию работы таймеров на обработку сигналов от кнопок — из-за многократных срабатываний прерываний может возникать эффект "дребезга", приводящий к ошибочному восприятию нажатий. Это подчеркивает необходимость правильной обработки прерываний и фильтрации сигналов для надежной работы ввода.
