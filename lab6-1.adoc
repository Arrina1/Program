= Лабораторная работа №6

ТАЙМЕРЫ И СИСТЕМЫ ТАКТИРОВАНИЯ.

Жуламанова А.М КЭ-413

:toc:
:toc-title: Оглавление

== Цель лабораторной работы

Произвести настройку Tim2 (сделать его насройку, запустить, проверить флаг переполнения).

Оформить лабораторную с описанием системы тактирования, настройки на внешний и внутренний источник тактирования, PLL, привести подробно настройку работы портов, привести примеры кода, картинки.

== 1. Описание системы тактирования

Система тактирования — это подсистема микроконтроллера, которая обеспечивает стабильную и точную работу процессора, периферии и других внутренних блоков. Основные задачи системы тактирования:

- Генерация базового тактового сигнала
- Формирование частоты тактирования с помощью умножителей/делителей (PLL)
- Возможность выбора источника тактирования (внутренний или внешний генератор)

Типичные источники тактирования:

- Внутренний RC-генератор (внутренний осциллятор) HSI (high-speed internal) 
- HSE (high-speed external)
- PLL (фазовращающий контур) для умножения частоты

На рисунке 1 приведена система тактирования микроконтроллера STM32F411

image::derevo.png[]

== 2. Настройка на внешний и внутренний источник тактирования

=== Внутренний источник тактирования

- Как правило, внутренний RC-генератор небольшой точности, но быстрого запуска.
- Для переключения на внутренний генератор обычно используется бит выбора источника в регистре тактирования (например, CLK_SRC = 0).
- Частота внутреннего генератора фиксирована.

=== Внешний источник тактирования

- Используется внешний генератор с высокой стабильностью.
- Для активации внешнего источника устанавливается бит выбора (CLK_SRC = 1), а также запускается и ждёт стабилизации внешний осциллятор.

== 3. PLL (фазовращающий контур)

- PLL позволяет увеличить частоту тактового сигнала до нужного значения.

- Работает путём умножения частоты выбранного источника (внутреннего или внешнего).

=== Настройка PLL включает:

1. Выбор входного источника (внутренний или внешний)
2. Установка коэффициентов умножения и деления
3. Включение PLL и ожидание стабилизации
4. Переключение на PLL как источник системного тактирования

== 4. Подробная настройка работы портов

Настройка основных источников тактирования выполняется через три главных регистра:

- RCC_CR
- RCC_CFGR
- RCC_PLLCFGR

Включение и выключение источников происходит через регистр CR (Clock Control register). 

На рисунке 2 приведен регистр CR.
image::cr.png[]

.Контроль работы
|===
||PLL|HSE|HSI
|RDY|Bit [25]|Bit [17]|Bit [1]
|ON|Bit [24]|Bit [16]|Bit [0]
|===

Здесь есть специальные биты, отвечающие за запуск генераторов (например, HSE, HSI, PLL): чтобы активировать источник, выставляют бит ON в 1, чтобы отключить — в 0. После команды включения необходима пауза — система аппаратно устанавливает бит RDY (ready), который сигнализирует о готовности источника. Пока RDY равен 0, источник ещё не стабилен и не готов к использованию.

После того как нужный источник тактовой частоты активен, происходит переключение системной частоты (SYSCLK) через регистр CFGR. 

image::cfgr.png[]
Рисунок 3 - регистр CFGR.

Здесь используются 4 младших бита — две пары: SW (switch) и SWS (switch status).

- SW — программный выбор источника тактирования,
- SWS — аппаратное подтверждение текущего активного источника.

Возможные значения для SW и SWS:

- 00 — выбран внутренний генератор HSI,
- 01 — выбран внешний генератор HSE,
- 10 — выбран источник PLL.

Для надёжной работы нужно убедиться, что аппаратный статус SWS совпадает с программным выбором SW, то есть переключение успешно завершено.

Настройка параметров PLL производится с помощью отдельного регистра PLLСFGR. 

На рисунке 4 приведен регистр PLLСFGR.
image::pllcfgr.png[]

Этот регистр следует сконфигурировать до включения PLL. В нём устанавливаются значения множителей и делителей, которые формируют конечную частоту тактирования. Частоту можно вычислить по формуле:

====
f = f(вход PLL) × (PLLN / PLLM) / PLLP
====

Таким образом, изменение значений PLLN, PLLM и PLLP позволяет получить практически любую частоту работы до 100 МГц (в зависимости от возможностей конкретного контроллера).

В итоге настройка тактирования выглядит так:

1. Включить нужный источник в регистре RCC_CR и дождаться готовности (появления бита RDY).
2. Настроить делители и множители PLL в RCC_PLLCFGR до запуска PLL.
3. Включить PLL и дождаться его готовности.
4. Переключить системный тактовый сигнал на выбранный источник в RCC_CFGR.
5. Проверить через биты SWS, что переключение завершено корректно.

== Пример настройки

*Настройка HSE*

[source, cpp]
----
  RCC::CR::HSEON::On::Set(); // <1>
  while (RCC::CR::HSERDY::NotReady::IsSet()) // <2> 
  {

  }
  RCC::CFGR::SW::Hse::Set(); //<3>
  while (!RCC::CFGR::SWS::Hse::IsSet())//<4>
  {

  }
  RCC::CR::HSION::Off::Set(); //<5> 
----

<1> включили
<2> проверили включение
<3> перекинули ключ SW на HSE
<4> проверили, что ключ переключился
<5> отключили HSI

*Настройка PLL на 36 МГц на основе HSE*

[source, cpp]
----
  RCC::PLLCFGR::PLLSRC::HseSource::Set(); //1
  
  RCC::PLLCFGR::PLLN0::Set(64); // n = 64
  RCC::PLLCFGR::PLLP0::Set(3); // p = 8
  RCC::PLLCFGR::FieldValues::Set(2); // m = 2
  //2
 RCC::CR::PLLON::On::Set(); //3
  while (RCC::CR::PLLRDY::Unclocked::IsSet()) //4
  {

  }
  RCC::CFGR::SW::Pll::Set(); //5
  while (!RCC::CFGR::SWS::Pll::IsSet()) //6
  {

  }
----

1. настроили источник ФАПЧ на HSE
2. определили коэффициенты 
3. включили
4. проверили, что включили
5. перевели SW на PLL
6. проверили, что перевели

== Таймеры. Настройка

Самый простой таймер для настройки имеет следующие характеристики:

- 24-битный таймер;

Для работы с таймером используются 3 основных регистра:

- LOAD — в этот регистр записывается значение, с которого таймер начнёт обратный отсчёт.
- VAL — здесь хранится текущее значение таймера, то есть сколько осталось до завершения отсчёта.
- CTRL — регистр управления, с помощью которого можно выбрать источник тактирования таймера, а также включить или выключить сам таймер.

=== Таймер TIM2

32-битный универсальный таймер, аналогичный TIM5.

Он управляется с помощью 5 регистров:

- PSC — предделитель частоты, который позволяет уменьшить скорость счета таймера, делая переполнение более медленным.
- ARR — регистр автоперезагрузки, задает время, по достижении которого таймер сбрасывается и начинает отсчет заново.
- CNT — текущий счётчик, в котором хранится текущее значение таймера.
- SR::UIF — флаговое поле в регистре состояния, сигнализирующее о наступлении события (например, переполнение или обнуление) и вызывающее прерывание.
- CR1::CEN — бит в регистре управления, отвечающий за включение или отключение таймера.

=== Настройка

==== 1. Настройки системного таймера:

[source, cpp]
----
#include "stkregisters.h" // для системного таймера

std::uint32_t SystemCoreClock = 16000000U;
std::uint32_t ticks = SystemCoreClock/1000U-1U; // 1
extern "C" {
int __low_level_init(void)
{
  STK::LOAD::RELOAD::Set(ticks); // 2
  STK::VAL::Write(0); //3
  STK::CTRL::CLKSOURCE::Set(0); //4
  STK::CTRL::ENABLE::Enable::Set(); // 5
  
  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////////
int main()
{ 
  /////////////////////////////////////
  for(;;)
  {   
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    if (STK::CTRL::COUNTFLAG::Overflow::IsSet()) // 6
    {
      modeController.RunCurrentMode(); 
    }
  }
  return 1;
}
----

1. Определяем задержку
2. Устанавливаем задержку на 1 мс
3. Сбрасываем текущее значение
4. Устанавливаем HSI как источник тактирования (он и по умолчанию 0, но для наглядности)
5. Включаем
6. Проверяем флаг на переполнение

Изображение 5 показывает, что все работает.

image::tim.gif[]

==== 2. Настройка таймера TIM2

[source, cpp]
----
#include "tim2registers.hpp" // for tim2

extern "C" {
int __low_level_init(void)
{
  RCC::APB1ENR::TIM2EN::Enable::Set(); // подаем тактирование
  TIM2::PSC::Set(0); // устанавливаем делитель частоты в 0
  TIM2::ARR::Write(99'999); // записываем значение для задержки в 1 мс
  TIM2::SR::UIF::Set(0); // сбрасываем флаг генерации прерывания
  TIM2::CNT::Set(0); // сбрасываем счетчик в 0
  TIM2::CR1::CEN::Set(1); // запускаем таймер

  RCC::APB2ENR::SYSCFGEN::Enable::Set();

  return 1;
}
}
////////////////////////////////////
int main()
{ 
 /////////////////////////////////
  
  for(;;)
  { 
    if (userButton.WasPressed())
    {
      modeController.SwitchMode(); 
    }
    if (TIM2::SR::UIF::InterruptPending::IsSet()) // если пришло прерывание
    {
      TIM2::CR1::CEN::Set(0); //останавливаем таймер
      TIM2::SR::UIF::Set(0); // сбрасываем флаг прерывания
      TIM2::CNT::Set(0); // устанавливаем счетчик в 0
      modeController.RunCurrentMode();
      TIM2::CR1::CEN::Set(1); //снова включаем таймер
    }
  }
  return 1;
}
----

=== Настройки порта

==== Основные сведения:

В рассматриваемом микроконтроллере присутствуют 5 типов портов, каждый из которых имеет 16 линий ввода/вывода.

Поддерживаются такие режимы входа:

- Плавающий цифровой — не рекомендуется использовать, кроме случаев создания радиопомех или экспериментов.
- Цифровой с подтяжкой к 0 или 1 — линия по умолчанию подключена к одному из уровней (0 или 1). При событии (например, замыкании) уровень меняется на противоположный. Часто подтяжку выполняют аппаратно, так как она надежнее встроенной с непредсказуемыми параметрами.
- Аналоговый вход — воспринимает аналоговый сигнал и интерпретирует значения выше среднего напряжения как 1, а ниже — как 0. Рекомендуется подавать сигналы, максимально близкие к 0 или 1, чтобы избежать ошибок распознавания.

image::pull_up_down.png[]
Рисунок 6 - Цифровой вход с подтяжкой.

image::port_off_on.png[]
Рисунок 7 - Подача питания или отключение

Режим цифрового выхода позволяет программно переключать линию между уровнями 0 и 1.

Для режимов с большими токами доступны:

- Альтернативная функция с открытым коллектором с подтяжкой (pull-up или pull-down)
- Альтернативная функция двухтактный выход с подтяжкой

==== Про регистры

- GPIOx_ODR — регистр выходных данных, управляет состоянием линий в режиме выхода.
- GPIOx_IDR — регистр входных данных, позволяет считывать состояние линий в режиме входа.
- GPIOx_MODER — задаёт режим работы каждого пина: вход, выход, аналоговый, или альтернативная функция.
- GPIOx_PUPDR — контролирует внутренние резисторы подтяжки: плавающий, подтяжка к 0 или к 1.
- GPIOx_SPEEDR — задаёт скорость переключения линий. Не рекомендуется ставить максимальную скорость на все линии, чтобы снизить энергопотребление.
- GPIOx_BSRR — позволяет атомарно устанавливать или сбрасывать биты GPIOx_ODR:
- младшие 16 бит — установка линии в 1,
- старшие 16 бит — сброс линии в 0.

Важно: запись 0 не меняет состояние, управляющим является бит, установленный в 1.

Приведем настройки:

[source, cpp]
----
int main()
{ 
  //Подать тактирование на порт А
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  //Порта А.5 на вывод
  GPIOA::MODER::MODER5::Output::Set() ;
}  
----

== Заключение

В ходе работы изучена основная периферия микроконтроллеров — порты, таймеры и источники тактирования. Рассмотрены ключевые особенности настройки источников тактирования, системного таймера и 32-битных таймеров общего назначения.

Особое внимание уделено влиянию работы таймеров на обработку сигналов от кнопок — из-за многократных срабатываний прерываний может возникать эффект "дребезга", приводящий к ошибочному восприятию нажатий. Это подчеркивает необходимость правильной обработки прерываний и фильтрации сигналов для надежной работы ввода.
